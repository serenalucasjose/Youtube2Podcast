<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Youtube2Podcast</title>
    <link rel="stylesheet" href="/css/styles.css">
    <link rel="stylesheet" href="/css/custom.css">
    <!-- Subset optimizado de Bootstrap Icons (~15KB vs ~1.5MB) -->
    <link rel="stylesheet" href="/css/icons.css">
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#dc2626">
    <link rel="icon" type="image/png" href="/icons/logo.png">
    <link rel="apple-touch-icon" href="/icons/logo.png">
    <script>
        // Theme initialization - runs before page renders to avoid flash
        (function() {
            const savedTheme = localStorage.getItem('theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        })();
    </script>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100 min-h-screen flex flex-col transition-colors duration-200">

    <!-- Mobile Menu Overlay -->
    <div id="mobile-menu-overlay" class="fixed inset-0 bg-black/60 z-[60] transition-opacity duration-300" style="display: none; opacity: 0;"></div>
    
    <!-- Mobile Sidebar Menu -->
    <aside id="mobile-sidebar" class="fixed top-0 left-0 h-full w-72 bg-white dark:bg-gray-800 z-[70] shadow-2xl flex flex-col transition-transform duration-300 ease-in-out" style="transform: translateX(-100%);">
        <!-- Sidebar Header -->
        <div class="flex items-center justify-between p-4 border-b border-gray-200 dark:border-gray-700">
            <div class="flex items-center gap-3">
                <img src="/icons/logo.png" alt="Youtube2Podcast" class="w-10 h-10 rounded-sm">
                <div>
                    <span class="font-semibold text-gray-900 dark:text-white">Youtube2Podcast</span>
                    <span class="ml-2 text-xs bg-gray-200 dark:bg-gray-700 px-1.5 py-0.5 rounded text-gray-600 dark:text-gray-300">v1.5</span>
                </div>
            </div>
            <button id="close-mobile-menu-btn" class="p-2 rounded-lg text-gray-500 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                <i class="bi bi-x-lg text-xl"></i>
            </button>
        </div>
        
        <!-- User Info -->
        <div class="p-4 border-b border-gray-200 dark:border-gray-700">
            <div class="flex items-center gap-3">
                <div class="w-10 h-10 rounded-full bg-gradient-to-br from-red-500 to-orange-500 flex items-center justify-center text-white font-bold">
                    <%= user.charAt(0).toUpperCase() %>
                </div>
                <div>
                    <p class="font-medium text-gray-900 dark:text-white"><%= user %></p>
                    <p class="text-xs text-gray-500 dark:text-gray-400">Videos: <%= episodeCount %>/<%= quotaLimit %></p>
                </div>
            </div>
        </div>
        
        <!-- Menu Items -->
        <nav class="flex-1 p-4 space-y-1 overflow-y-auto">
            <!-- Theme Toggle -->
            <button id="mobile-theme-toggle" class="w-full flex items-center gap-3 px-4 py-3 rounded-lg text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                <i id="mobile-theme-icon-dark" class="bi bi-moon-fill text-lg"></i>
                <i id="mobile-theme-icon-light" class="bi bi-sun-fill text-lg text-yellow-500 hidden"></i>
                <span id="mobile-theme-label">Modo Oscuro</span>
            </button>
            
            <!-- Push Notifications -->
            <button id="mobile-push-btn" class="w-full flex items-center gap-3 px-4 py-3 rounded-lg text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                <i id="mobile-push-icon-off" class="bi bi-bell text-lg"></i>
                <i id="mobile-push-icon-on" class="bi bi-bell-fill text-lg text-green-500 hidden"></i>
                <span id="mobile-push-label">Notificaciones Push</span>
            </button>
            
            <!-- Walk Mode -->
            <button id="mobile-walk-mode-btn" class="w-full flex items-center gap-3 px-4 py-3 rounded-lg text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                <i class="bi bi-person-walking text-lg"></i>
                <span>Modo Caminata</span>
            </button>
            
            <!-- Sleep Timer -->
            <button id="mobile-sleep-timer-btn" class="w-full flex items-center gap-3 px-4 py-3 rounded-lg text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                <i class="bi bi-stopwatch text-lg"></i>
                <span>Temporizador de Sue√±o</span>
                <span id="mobile-timer-badge" class="hidden ml-auto text-xs bg-orange-500 text-white rounded px-2 py-0.5 font-medium"></span>
            </button>
            
            <% if (typeof isAdmin !== 'undefined' && isAdmin) { %>
            <div class="pt-2 mt-2 border-t border-gray-200 dark:border-gray-700">
                <a href="/admin" class="w-full flex items-center gap-3 px-4 py-3 rounded-lg text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                    <i class="bi bi-gear-fill text-lg"></i>
                    <span>Panel de Admin</span>
                </a>
            </div>
            <% } %>
        </nav>
        
        <!-- Logout -->
        <div class="p-4 border-t border-gray-200 dark:border-gray-700">
            <a href="/logout" class="w-full flex items-center gap-3 px-4 py-3 rounded-lg text-red-600 dark:text-red-400 hover:bg-red-50 dark:hover:bg-red-900/20 transition-colors">
                <i class="bi bi-box-arrow-left text-lg"></i>
                <span>Cerrar Sesi√≥n</span>
            </a>
        </div>
    </aside>

    <nav class="bg-white dark:bg-gray-800 shadow-lg sticky top-0 z-50 transition-colors duration-200 overflow-x-hidden">
        <div class="max-w-7xl mx-auto px-2 sm:px-4 lg:px-8">
            <div class="flex justify-between py-2 items-center gap-2">
                <!-- Mobile Menu Button + Logo -->
                <div class="flex items-center gap-2 flex-shrink-0">
                    <!-- Hamburger Button - visible on mobile only -->
                    <button id="open-mobile-menu-btn" class="lg:hidden p-2 rounded-lg text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                        <i class="bi bi-list text-2xl"></i>
                    </button>
                    <img src="/icons/logo.png" alt="Youtube2Podcast" class="w-auto rounded-sm hidden xs:block" style="max-width: 60px;">
                    <span class="text-xs bg-gray-200 dark:bg-gray-700 px-1.5 py-0.5 rounded text-gray-600 dark:text-gray-300 hidden sm:inline">v1.5</span>
                </div>
                
                <!-- Right side controls -->
                <div class="flex items-center gap-1 sm:gap-2 flex-wrap justify-end">
                    <!-- Push Notifications Toggle -->
                    <button id="push-notifications-btn" title="Notificaciones Push" class="nav-icon-btn text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white relative">
                        <i id="push-icon-off" class="bi bi-bell text-lg sm:text-xl"></i>
                        <i id="push-icon-on" class="bi bi-bell-fill text-lg sm:text-xl hidden text-green-500"></i>
                        <span id="push-badge" class="hidden absolute -top-1 -right-1 w-2 h-2 bg-green-500 rounded-full"></span>
                    </button>
                    
                    <!-- Theme Toggle -->
                    <button id="theme-toggle-btn" title="Cambiar tema" aria-label="Cambiar tema" class="nav-icon-btn text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                        <i id="theme-icon-dark" class="bi bi-moon-fill text-lg sm:text-xl"></i>
                        <i id="theme-icon-light" class="bi bi-sun-fill text-lg sm:text-xl hidden text-yellow-500"></i>
                    </button>
                    
                    <!-- Walk Mode - hidden on very small screens -->
                    <button id="walk-mode-btn" title="Activar Modo Caminata" class="nav-icon-btn text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white hidden sm:flex">
                        <i class="bi bi-person-walking text-lg sm:text-xl"></i>
                    </button>
                    
                    <!-- Sleep Timer -->
                    <button id="sleep-timer-btn" title="Temporizador de Sue√±o" class="nav-icon-btn text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white relative">
                        <i class="bi bi-stopwatch text-lg sm:text-xl"></i>
                    </button>
                    <span id="timer-badge" class="hidden text-[8px] bg-orange-500 text-white rounded px-1 py-0.5 font-medium"></span>
                    
                    <!-- User info and actions -->
                    <div class="flex items-center gap-1 sm:gap-2 ml-1 sm:ml-2 pl-1 sm:pl-2 border-l border-gray-300 dark:border-gray-600">
                        <span class="text-gray-500 dark:text-gray-400 text-xs hidden md:inline"><%= user %></span>
                        <span class="text-xs bg-gray-200 dark:bg-gray-700 px-1.5 py-0.5 rounded text-gray-600 dark:text-gray-300" title="Videos usados">
                            <%= episodeCount %>/<%= quotaLimit %>
                        </span>
                        <% if (typeof isAdmin !== 'undefined' && isAdmin) { %>
                            <a href="/admin" class="admin-link text-xs sm:text-sm">Admin</a>
                        <% } %>
                        <a href="/logout" class="nav-icon-btn text-gray-500 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white text-xs sm:text-sm whitespace-nowrap">Salir</a>
                    </div>
                </div>
            </div>
        </div>
    </nav>

    <!-- Push Notifications Banner -->
    <div id="push-banner" class="hidden bg-gradient-to-r from-blue-600/90 to-indigo-600/90 text-white py-3 px-4 shadow-md">
        <div class="max-w-7xl mx-auto flex flex-col sm:flex-row items-center justify-between gap-3">
            <div class="flex items-center gap-3 text-sm">
                <i class="bi bi-lightbulb text-yellow-300 text-lg flex-shrink-0"></i>
                <span>
                    <strong>Tip:</strong> Activa las notificaciones para recibir avisos cuando tus descargas terminen. 
                    As√≠ podr√°s dejar la aplicaci√≥n trabajando en segundo plano.
                </span>
            </div>
            <div class="flex items-center gap-2 flex-shrink-0">
                <button id="push-banner-activate" class="bg-white text-blue-700 hover:bg-blue-50 font-medium text-sm px-4 py-1.5 rounded-lg transition shadow-sm">
                    <i class="bi bi-bell me-1"></i> Activar
                </button>
                <button id="push-banner-dismiss" class="text-white/80 hover:text-white p-1.5 rounded-lg hover:bg-white/10 transition" title="No gracias">
                    <i class="bi bi-x-lg"></i>
                </button>
            </div>
        </div>
    </div>

    <main class="flex-grow container mx-auto px-4 py-8" id="main-content">
        
        <% if (typeof error !== 'undefined' && error) { %>
            <div class="max-w-2xl mx-auto mb-4">
                <div class="bg-red-900/50 border border-red-500 text-red-200 px-4 py-3 rounded-lg text-sm">
                    <%= error %>
                </div>
            </div>
        <% } %>

        <!-- Input Section -->
        <div class="max-w-2xl mx-auto mb-8" id="input-section">
            <form action="/add" method="POST" class="flex gap-4 mb-6" onsubmit="document.getElementById('add-btn').disabled = true; document.getElementById('add-btn').innerText = '...';">
                <input type="url" name="url" placeholder="Pegar URL de YouTube aqu√≠..." required 
                    class="flex-grow px-4 py-3 rounded-lg bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 focus:border-red-500 focus:ring-1 focus:ring-red-500 outline-none transition duration-200 text-gray-900 dark:text-white placeholder-gray-400">
                <button id="add-btn" type="submit" class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg transition duration-200 shadow-lg transform hover:scale-105">
                    Agregar
                </button>
            </form>
            
            <div class="flex justify-between items-center gap-4">
                 <!-- Search Input -->
                <input type="text" id="searchInput" placeholder="Buscar episodios..." 
                    class="flex-grow px-4 py-2 rounded-lg bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 focus:border-gray-500 outline-none text-gray-700 dark:text-gray-300 placeholder-gray-400 dark:placeholder-gray-500 text-sm">
                
                <!-- Bulk Actions -->
                 <div class="flex items-center gap-2" id="bulk-actions" style="display: none;">
                    <button onclick="submitBulkDelete()" class="bg-red-900 hover:bg-red-700 text-red-200 text-xs py-2 px-3 rounded border border-red-700 transition">
                        Borrar Seleccionados (<span id="selected-count">0</span>)
                    </button>
                 </div>
            </div>
            <div class="mt-2 flex items-center gap-2">
                <input type="checkbox" id="select-all" class="episode-checkbox" style="margin-right: 0;">
                <label for="select-all" class="text-xs text-gray-400 cursor-pointer select-none">Seleccionar todos</label>
            </div>
        </div>

        <!-- List / Grid -->
        <form id="delete-form" action="/delete" method="POST">
        <% if (episodes.length === 0) { %>
            <div class="text-center text-gray-500 mt-20">
                <p class="text-xl">No hay podcasts a√∫n.</p>
                <p class="text-sm mt-2">Agrega una URL de YouTube para comenzar.</p>
            </div>
        <% } else { %>
            <div id="episodesGrid">
                <% episodes.forEach(episode => { %>
                    <%- include('partials/episode_card', { episode }) %>
                <% }); %>
            </div>
        <% } %>
        </form>

    </main>

    <footer class="bg-white dark:bg-gray-800 text-gray-500 py-6 mt-12 text-center text-sm border-t border-gray-200 dark:border-gray-700">
        <p>Youtube2Podcast v1.5 | <a href="/logout" class="hover:text-gray-700 dark:hover:text-gray-300">Salir</a></p>
    </footer>

    <!-- Voice Selection Modal -->
    <div id="voice-modal" class="fixed inset-0 bg-black bg-opacity-80 z-[9998] hidden flex items-center justify-center p-6">
        <div class="bg-gray-800 rounded-xl shadow-2xl max-w-lg w-full max-h-[85vh] overflow-hidden border border-gray-700">
            <div class="p-6 border-b border-gray-700 flex justify-between items-center">
                <h3 class="text-xl font-semibold text-white">Seleccionar Voz</h3>
                <button onclick="closeVoiceModal()" class="text-gray-400 hover:text-white">
                    <i class="bi bi-x-lg"></i>
                </button>
            </div>
            <div class="p-6 overflow-y-auto max-h-[60vh]">
                <input type="hidden" id="voice-episode-id" value="">
                
                <!-- Espa√±a -->
                <div class="mb-6">
                    <h4 class="text-sm font-medium text-gray-400 mb-3 flex items-center gap-2">
                        <span>üá™üá∏</span> Espa√±a
                    </h4>
                    <div class="grid grid-cols-2 gap-3">
                        <button type="button" onclick="selectVoice('es-ES-AlvaroNeural')" class="voice-option" data-voice="es-ES-AlvaroNeural">
                            <span class="voice-gender">‚ôÇ</span> √Ålvaro
                        </button>
                        <button type="button" onclick="selectVoice('es-ES-ElviraNeural')" class="voice-option" data-voice="es-ES-ElviraNeural">
                            <span class="voice-gender female">‚ôÄ</span> Elvira
                        </button>
                    </div>
                </div>
                
                <!-- M√©xico -->
                <div class="mb-6">
                    <h4 class="text-sm font-medium text-gray-400 mb-3 flex items-center gap-2">
                        <span>üá≤üáΩ</span> M√©xico
                    </h4>
                    <div class="grid grid-cols-2 gap-3">
                        <button type="button" onclick="selectVoice('es-MX-JorgeNeural')" class="voice-option" data-voice="es-MX-JorgeNeural">
                            <span class="voice-gender">‚ôÇ</span> Jorge
                        </button>
                        <button type="button" onclick="selectVoice('es-MX-DaliaNeural')" class="voice-option" data-voice="es-MX-DaliaNeural">
                            <span class="voice-gender female">‚ôÄ</span> Dalia
                        </button>
                    </div>
                </div>
                
                <!-- Argentina -->
                <div class="mb-6">
                    <h4 class="text-sm font-medium text-gray-400 mb-3 flex items-center gap-2">
                        <span>üá¶üá∑</span> Argentina
                    </h4>
                    <div class="grid grid-cols-2 gap-3">
                        <button type="button" onclick="selectVoice('es-AR-TomasNeural')" class="voice-option" data-voice="es-AR-TomasNeural">
                            <span class="voice-gender">‚ôÇ</span> Tom√°s
                        </button>
                        <button type="button" onclick="selectVoice('es-AR-ElenaNeural')" class="voice-option" data-voice="es-AR-ElenaNeural">
                            <span class="voice-gender female">‚ôÄ</span> Elena
                        </button>
                    </div>
                </div>
                
                <!-- Colombia -->
                <div class="mb-6">
                    <h4 class="text-sm font-medium text-gray-400 mb-3 flex items-center gap-2">
                        <span>üá®üá¥</span> Colombia
                    </h4>
                    <div class="grid grid-cols-2 gap-3">
                        <button type="button" onclick="selectVoice('es-CO-GonzaloNeural')" class="voice-option" data-voice="es-CO-GonzaloNeural">
                            <span class="voice-gender">‚ôÇ</span> Gonzalo
                        </button>
                        <button type="button" onclick="selectVoice('es-CO-SalomeNeural')" class="voice-option" data-voice="es-CO-SalomeNeural">
                            <span class="voice-gender female">‚ôÄ</span> Salom√©
                        </button>
                    </div>
                </div>
            </div>
            <div class="p-6 border-t border-gray-700 flex justify-end gap-4">
                <button onclick="closeVoiceModal()" class="px-4 py-2 text-sm text-gray-400 hover:text-white transition">
                    Cancelar
                </button>
                <button id="start-translation-btn" onclick="confirmVoiceSelection()" class="px-4 py-2 text-sm bg-yellow-600 hover:bg-yellow-500 text-white rounded-lg transition font-medium">
                    Iniciar Traducci√≥n
                </button>
            </div>
        </div>
    </div>

    <!-- Transcription Language Modal -->
    <div id="transcription-modal" class="fixed inset-0 bg-black bg-opacity-80 z-[9998] hidden flex items-center justify-center p-6">
        <div class="bg-gray-800 rounded-xl shadow-2xl max-w-md w-full max-h-[85vh] overflow-hidden border border-gray-700">
            <div class="p-6 border-b border-gray-700 flex justify-between items-center">
                <h3 class="text-xl font-semibold text-white">Obtener Transcripci√≥n</h3>
                <button onclick="closeTranscriptionModal()" class="text-gray-400 hover:text-white">
                    <i class="bi bi-x-lg"></i>
                </button>
            </div>
            <div class="p-6">
                <input type="hidden" id="transcription-episode-id" value="">
                
                <p class="text-gray-400 text-sm mb-4">Selecciona el idioma del audio para obtener una transcripci√≥n m√°s precisa:</p>
                
                <select id="transcription-language" class="w-full px-4 py-3 rounded-lg bg-gray-700 border border-gray-600 text-white focus:border-purple-500 focus:ring-1 focus:ring-purple-500 outline-none">
                    <option value="en">English</option>
                    <option value="es">Espa√±ol</option>
                    <option value="fr">Fran√ßais</option>
                    <option value="de">Deutsch</option>
                    <option value="it">Italiano</option>
                    <option value="pt">Portugu√™s</option>
                    <option value="nl">Nederlands</option>
                    <option value="pl">Polski</option>
                    <option value="ru">–†—É—Å—Å–∫–∏–π</option>
                    <option value="ja">Êó•Êú¨Ë™û</option>
                    <option value="ko">ÌïúÍµ≠Ïñ¥</option>
                    <option value="zh">‰∏≠Êñá</option>
                    <option value="ar">ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</option>
                    <option value="hi">‡§π‡§ø‡§®‡•ç‡§¶‡•Ä</option>
                    <option value="tr">T√ºrk√ße</option>
                    <option value="vi">Ti·∫øng Vi·ªát</option>
                    <option value="uk">–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞</option>
                    <option value="sv">Svenska</option>
                </select>
                
                <p class="text-gray-500 text-xs mt-3">
                    <i class="bi bi-info-circle"></i> La transcripci√≥n se generar√° como PDF con timestamps.
                </p>
            </div>
            <div class="p-6 border-t border-gray-700 flex justify-end gap-4">
                <button onclick="closeTranscriptionModal()" class="px-4 py-2 text-sm text-gray-400 hover:text-white transition">
                    Cancelar
                </button>
                <button id="start-transcription-btn" onclick="confirmTranscription()" class="px-4 py-2 text-sm bg-purple-600 hover:bg-purple-500 text-white rounded-lg transition font-medium">
                    <i class="bi bi-file-earmark-text me-1"></i> Iniciar Transcripci√≥n
                </button>
            </div>
        </div>
    </div>

    <!-- Sleep Timer Modal -->
    <div id="sleep-timer-modal" class="fixed inset-0 bg-black bg-opacity-80 z-[9998] hidden flex items-center justify-center px-4 py-6 sm:p-6">
        <div class="bg-gray-800 rounded-xl shadow-2xl w-full max-w-sm overflow-hidden border border-gray-700">
            <div class="p-6 border-b border-gray-700 flex justify-between items-center">
                <h3 class="text-xl font-semibold text-white"><i class="bi bi-stopwatch me-2"></i>Temporizador</h3>
                <button onclick="closeSleepTimerModal()" class="text-gray-400 hover:text-white">
                    <i class="bi bi-x-lg"></i>
                </button>
            </div>
            <div class="p-6">
                <p class="text-gray-400 text-sm mb-4">La reproducci√≥n se detendr√° autom√°ticamente despu√©s del tiempo seleccionado:</p>
                
                <div class="grid grid-cols-2 gap-3">
                    <button onclick="startSleepTimer(15)" class="timer-option py-3 px-4 rounded-lg bg-gray-700 hover:bg-orange-600 text-white transition font-medium">
                        15 min
                    </button>
                    <button onclick="startSleepTimer(30)" class="timer-option py-3 px-4 rounded-lg bg-gray-700 hover:bg-orange-600 text-white transition font-medium">
                        30 min
                    </button>
                    <button onclick="startSleepTimer(45)" class="timer-option py-3 px-4 rounded-lg bg-gray-700 hover:bg-orange-600 text-white transition font-medium">
                        45 min
                    </button>
                    <button onclick="startSleepTimer(60)" class="timer-option py-3 px-4 rounded-lg bg-gray-700 hover:bg-orange-600 text-white transition font-medium">
                        60 min
                    </button>
                </div>
                
                <!-- Active Timer Display -->
                <div id="active-timer-display" class="hidden mt-6 p-4 bg-orange-900/30 border border-orange-700 rounded-lg text-center">
                    <p class="text-orange-400 text-sm mb-2">Temporizador activo</p>
                    <p id="timer-countdown" class="text-3xl font-bold text-white">00:00</p>
                    <button onclick="cancelSleepTimer()" class="mt-3 text-sm text-red-400 hover:text-red-300 transition">
                        <i class="bi bi-x-circle me-1"></i> Cancelar
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Walk Mode Overlay -->
    <div id="walk-overlay" class="fixed inset-0 bg-black bg-opacity-90 z-[9999] hidden flex flex-col items-center justify-center text-center touch-none select-none p-4">
        <div class="text-gray-400 mb-6 sm:mb-8 animate-pulse px-4">
            <i class="bi bi-lock-fill text-5xl sm:text-6xl md:text-7xl mx-auto mb-3 sm:mb-4 block"></i>
            <h2 class="text-xl sm:text-2xl md:text-3xl font-bold text-white">Modo Caminata Activo</h2>
            <p class="mt-2 text-xs sm:text-sm md:text-base">Pantalla bloqueada para evitar toques accidentales.</p>
        </div>
        <div class="w-40 h-40 sm:w-52 sm:h-52 md:w-64 md:h-64 border-4 border-gray-700 rounded-full flex items-center justify-center active:border-red-500 transition-colors duration-300" id="unlock-area">
            <p class="text-xs sm:text-sm text-gray-500 px-4">Mant√©n presionado para desbloquear</p>
        </div>
    </div>

    <script>
        // === Mobile Menu ===
        const mobileMenuOverlay = document.getElementById('mobile-menu-overlay');
        const mobileSidebar = document.getElementById('mobile-sidebar');
        const openMobileMenuBtn = document.getElementById('open-mobile-menu-btn');
        const closeMobileMenuBtn = document.getElementById('close-mobile-menu-btn');
        let mobileMenuOpen = false;
        
        function openMobileMenu() {
            mobileMenuOpen = true;
            mobileMenuOverlay.style.display = 'block';
            setTimeout(() => {
                mobileMenuOverlay.style.opacity = '1';
            }, 10);
            mobileSidebar.style.transform = 'translateX(0)';
            document.body.style.overflow = 'hidden';
        }
        
        function closeMobileMenu() {
            mobileMenuOpen = false;
            mobileMenuOverlay.style.opacity = '0';
            mobileSidebar.style.transform = 'translateX(-100%)';
            document.body.style.overflow = '';
            setTimeout(() => {
                mobileMenuOverlay.style.display = 'none';
            }, 300);
        }
        
        openMobileMenuBtn.addEventListener('click', openMobileMenu);
        closeMobileMenuBtn.addEventListener('click', closeMobileMenu);
        mobileMenuOverlay.addEventListener('click', closeMobileMenu);
        
        // Close mobile menu on escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && mobileMenuOpen) {
                closeMobileMenu();
            }
        });

        // Search
        const searchInput = document.getElementById('searchInput');
        if (searchInput) {
            searchInput.addEventListener('keyup', function(e) {
                const term = e.target.value.toLowerCase();
                const cards = document.querySelectorAll('.episode-card');
                cards.forEach(card => {
                    const title = card.querySelector('.episode-title').innerText.toLowerCase();
                    card.style.display = title.includes(term) ? '' : 'none';
                });
            });
        }

        // Selection Logic
        const selectAllCheckbox = document.getElementById('select-all');
        const episodeCheckboxes = document.querySelectorAll('.episode-checkbox[name="ids"]');
        const bulkActionsDiv = document.getElementById('bulk-actions');
        const selectedCountSpan = document.getElementById('selected-count');

        function updateBulkUI() {
            const count = document.querySelectorAll('.episode-checkbox[name="ids"]:checked').length;
            selectedCountSpan.innerText = count;
            bulkActionsDiv.style.display = count > 0 ? 'flex' : 'none';
        }

        selectAllCheckbox.addEventListener('change', (e) => {
            // Re-query in case of dynamic changes, though not expected here
            const currentCheckboxes = document.querySelectorAll('.episode-checkbox[name="ids"]');
            currentCheckboxes.forEach(cb => cb.checked = e.target.checked);
            updateBulkUI();
        });

        // Event delegation for better performance? Or just re-attach
        // Re-querying is safer if we had infinite scroll, but static list for now
        document.querySelectorAll('.episode-checkbox[name="ids"]').forEach(cb => {
            cb.addEventListener('change', updateBulkUI);
        });

        function submitBulkDelete() {
            if (confirm('¬øEst√°s seguro de que deseas eliminar los episodios seleccionados?')) {
                document.getElementById('delete-form').submit();
            }
        }

        function confirmDelete(id) {
            if (confirm('¬øEliminar este episodio?')) {
                const form = document.createElement('form');
                form.method = 'POST';
                form.action = '/delete';
                const input = document.createElement('input');
                input.type = 'hidden';
                input.name = 'ids';
                input.value = id;
                form.appendChild(input);
                document.body.appendChild(form);
                form.submit();
            }
        }

        // SSE for auto-reload when download/translation completes
        let evtSource = null;
        let sseRetryCount = 0;
        const SSE_MAX_RETRIES = 5;
        const SSE_RETRY_DELAY = 5000;
        
        function connectSSE() {
            try {
                if (evtSource) {
                    evtSource.close();
                }
                
                evtSource = new EventSource('/progress');
                
                evtSource.onopen = function() {
                    sseRetryCount = 0; // Reset on successful connection
                };
                
                evtSource.onerror = function(err) {
                    console.warn('SSE connection error', err);
                    evtSource.close();
                    evtSource = null;
                    
                    // Limit retries to avoid infinite loop
                    if (sseRetryCount < SSE_MAX_RETRIES) {
                        sseRetryCount++;
                        console.log(`SSE retry ${sseRetryCount}/${SSE_MAX_RETRIES} in ${SSE_RETRY_DELAY/1000}s...`);
                        setTimeout(connectSSE, SSE_RETRY_DELAY);
                    } else {
                        console.warn('SSE max retries reached. Live updates disabled.');
                    }
                };
                
                evtSource.onmessage = handleSSEMessage;
            } catch (e) {
                console.warn('SSE initialization failed:', e);
            }
        }
        
        function handleSSEMessage(event) {
            const data = JSON.parse(event.data);
            console.log('SSE Event:', data);

            // Handle transcription events
            if (data.type === 'transcription') {
                console.log('Transcription SSE event:', data);
                if (data.transcriptionStatus === 'ready') {
                    console.log('Transcription ready, updating card...');
                    refreshEpisodeCard(data.episodeId);
                } else if (data.transcriptionStatus === 'error') {
                    refreshEpisodeCard(data.episodeId);
                } else if (data.transcriptionStatus === 'processing') {
                    updateTranscriptionProgress(data.episodeId, data.videoId, data.stage, data.percent, data.message);
                    const card = document.querySelector(`.episode-card[data-youtube-id="${data.videoId}"]`);
                    if (card && !card.classList.contains('transcribing')) {
                        card.classList.add('transcribing');
                        ensureTranscriptionLogsContainer(card);
                    }
                }
                return;
            }

            // Handle translation events
            if (data.type === 'translation') {
                console.log('Translation SSE event:', data);
                if (data.translationStatus === 'ready') {
                    console.log('Translation ready, updating card...');
                    refreshEpisodeCard(data.episodeId);
                } else if (data.translationStatus === 'error') {
                    refreshEpisodeCard(data.episodeId);
                } else if (data.translationStatus === 'processing') {
                    updateTranslationProgress(data.episodeId, data.videoId, data.stage, data.percent, data.message);
                    // Mark card as translating if not already
                    const card = document.querySelector(`.episode-card[data-youtube-id="${data.videoId}"]`);
                    if (card && !card.classList.contains('translating')) {
                        card.classList.add('translating');
                        // A√±adir contenedor de logs si no existe
                        ensureLogsContainer(card);
                    }
                }
                return;
            }

            // Handle download events
            if (data.status === 'done') {
                // Buscar el episodeId por videoId
                const card = document.querySelector(`.episode-card[data-youtube-id="${data.videoId}"]`);
                if (card) {
                    refreshEpisodeCard(card.dataset.episodeId);
                }
            } else if (data.status === 'error') {
                updateCardToError(data.videoId);
            }
        }
        
        // Initialize SSE connection
        connectSSE();

        // Helper function to update a card to error state
        function updateCardToError(videoId) {
            const card = document.querySelector(`.episode-card[data-youtube-id="${videoId}"]`);
            if (card) {
                card.classList.remove('processing');
                const statusSpan = card.querySelector('.card-date span');
                if (statusSpan) {
                    statusSpan.className = 'text-red-500';
                    statusSpan.innerText = 'Error';
                }
                const thumbContainer = card.querySelector('.aspect-video > div');
                if (thumbContainer) {
                    thumbContainer.innerHTML = `
                        <svg class="w-6 h-6 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                        </svg>
                    `;
                }
            }
        }

        // Voice Selection Modal
        let selectedVoice = 'es-ES-AlvaroNeural';
        const voiceModal = document.getElementById('voice-modal');
        const voiceEpisodeIdInput = document.getElementById('voice-episode-id');
        
        function openVoiceModal(episodeId) {
            voiceEpisodeIdInput.value = episodeId;
            selectedVoice = 'es-ES-AlvaroNeural'; // Reset to default
            // Reset visual selection
            document.querySelectorAll('.voice-option').forEach(btn => btn.classList.remove('selected'));
            document.querySelector('.voice-option[data-voice="es-ES-AlvaroNeural"]').classList.add('selected');
            voiceModal.classList.remove('hidden');
        }
        
        function closeVoiceModal() {
            voiceModal.classList.add('hidden');
        }
        
        function selectVoice(voice) {
            selectedVoice = voice;
            document.querySelectorAll('.voice-option').forEach(btn => btn.classList.remove('selected'));
            document.querySelector(`.voice-option[data-voice="${voice}"]`).classList.add('selected');
        }
        
        function confirmVoiceSelection() {
            const episodeId = voiceEpisodeIdInput.value;
            closeVoiceModal();
            startTranslation(episodeId, selectedVoice);
        }
        
        // Close modal on backdrop click
        voiceModal.addEventListener('click', (e) => {
            if (e.target === voiceModal) closeVoiceModal();
        });
        
        // Close modal on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && !voiceModal.classList.contains('hidden')) {
                closeVoiceModal();
            }
            if (e.key === 'Escape' && !transcriptionModal.classList.contains('hidden')) {
                closeTranscriptionModal();
            }
            if (e.key === 'Escape' && !sleepTimerModal.classList.contains('hidden')) {
                closeSleepTimerModal();
            }
        });

        // Transcription Modal
        const transcriptionModal = document.getElementById('transcription-modal');
        const transcriptionEpisodeIdInput = document.getElementById('transcription-episode-id');
        const transcriptionLanguageSelect = document.getElementById('transcription-language');
        
        function openTranscriptionModal(episodeId) {
            transcriptionEpisodeIdInput.value = episodeId;
            transcriptionLanguageSelect.value = 'en'; // Default to English
            transcriptionModal.classList.remove('hidden');
        }
        
        function closeTranscriptionModal() {
            transcriptionModal.classList.add('hidden');
        }
        
        async function confirmTranscription() {
            const episodeId = transcriptionEpisodeIdInput.value;
            const language = transcriptionLanguageSelect.value;
            closeTranscriptionModal();
            
            try {
                const response = await fetch(`/transcribe/${episodeId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ language })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    await refreshEpisodeCard(episodeId);
                } else {
                    alert('Error: ' + (data.error || 'No se pudo iniciar la transcripci√≥n'));
                }
            } catch (err) {
                console.error('Transcription error:', err);
                alert('Error de conexi√≥n al iniciar la transcripci√≥n');
            }
        }
        
        // Close transcription modal on backdrop click
        transcriptionModal.addEventListener('click', (e) => {
            if (e.target === transcriptionModal) closeTranscriptionModal();
        });

        // Sleep Timer
        const sleepTimerBtn = document.getElementById('sleep-timer-btn');
        const sleepTimerModal = document.getElementById('sleep-timer-modal');
        const timerBadge = document.getElementById('timer-badge');
        const timerCountdown = document.getElementById('timer-countdown');
        const activeTimerDisplay = document.getElementById('active-timer-display');
        
        let sleepTimerId = null;
        let sleepTimerEndTime = null;
        let sleepTimerUpdateInterval = null;
        
        sleepTimerBtn.addEventListener('click', () => {
            sleepTimerModal.classList.remove('hidden');
            updateTimerModalDisplay();
        });
        
        function closeSleepTimerModal() {
            sleepTimerModal.classList.add('hidden');
        }
        
        sleepTimerModal.addEventListener('click', (e) => {
            if (e.target === sleepTimerModal) closeSleepTimerModal();
        });
        
        function startSleepTimer(minutes) {
            // Cancel existing timer if any
            if (sleepTimerId) {
                clearTimeout(sleepTimerId);
                clearInterval(sleepTimerUpdateInterval);
            }
            
            sleepTimerEndTime = Date.now() + (minutes * 60 * 1000);
            
            // Set the main timeout
            sleepTimerId = setTimeout(() => {
                stopAllAudio();
                showTimerNotification();
                cancelSleepTimer();
            }, minutes * 60 * 1000);
            
            // Update display every second
            sleepTimerUpdateInterval = setInterval(updateTimerDisplay, 1000);
            
            updateTimerDisplay();
            updateTimerModalDisplay();
            closeSleepTimerModal();
        }
        
        function cancelSleepTimer() {
            if (sleepTimerId) {
                clearTimeout(sleepTimerId);
                sleepTimerId = null;
            }
            if (sleepTimerUpdateInterval) {
                clearInterval(sleepTimerUpdateInterval);
                sleepTimerUpdateInterval = null;
            }
            sleepTimerEndTime = null;
            
            timerBadge.classList.add('hidden');
            timerBadge.textContent = '';
            sleepTimerBtn.classList.remove('timer-active');
            updateTimerModalDisplay();
        }
        
        function updateTimerDisplay() {
            if (!sleepTimerEndTime) return;
            
            const remaining = Math.max(0, sleepTimerEndTime - Date.now());
            const minutes = Math.floor(remaining / 60000);
            const seconds = Math.floor((remaining % 60000) / 1000);
            
            const displayText = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            timerBadge.textContent = minutes > 0 ? `${minutes}m` : `${seconds}s`;
            timerBadge.classList.remove('hidden');
            sleepTimerBtn.classList.add('timer-active');
            
            if (timerCountdown) {
                timerCountdown.textContent = displayText;
            }
        }
        
        function updateTimerModalDisplay() {
            if (sleepTimerEndTime) {
                activeTimerDisplay.classList.remove('hidden');
                updateTimerDisplay();
            } else {
                activeTimerDisplay.classList.add('hidden');
            }
        }
        
        function stopAllAudio() {
            // Pause all audio elements
            document.querySelectorAll('audio').forEach(audio => {
                if (!audio.paused) {
                    audio.pause();
                }
            });
            
            // Update all custom player UIs
            document.querySelectorAll('.custom-audio-player').forEach(player => {
                player.classList.remove('playing');
                const playIcon = player.querySelector('.play-icon');
                const pauseIcon = player.querySelector('.pause-icon');
                if (playIcon) playIcon.classList.remove('hidden');
                if (pauseIcon) pauseIcon.classList.add('hidden');
            });
        }
        
        function showTimerNotification() {
            // Show a toast/notification
            const toast = document.createElement('div');
            toast.className = 'fixed bottom-4 left-1/2 transform -translate-x-1/2 bg-orange-600 text-white px-6 py-3 rounded-lg shadow-lg z-[10000] flex items-center gap-2';
            toast.innerHTML = '<i class="bi bi-stopwatch"></i> Reproducci√≥n detenida por temporizador';
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.transition = 'opacity 0.5s';
                toast.style.opacity = '0';
                setTimeout(() => toast.remove(), 500);
            }, 4000);
        }

        // Translation Functions
        async function startTranslation(episodeId, voice = 'es-ES-AlvaroNeural') {
            try {
                const response = await fetch(`/translate/${episodeId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ voice })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    // Actualizar tarjeta sin recargar p√°gina
                    await refreshEpisodeCard(episodeId);
                } else {
                    alert('Error: ' + (data.error || 'No se pudo iniciar la traducci√≥n'));
                }
            } catch (err) {
                console.error('Translation error:', err);
                alert('Error de conexi√≥n al iniciar la traducci√≥n');
            }
        }

        function updateTranslationProgress(episodeId, videoId, stage, percent, message) {
            const card = document.querySelector(`.episode-card[data-youtube-id="${videoId}"]`);
            if (card) {
                console.log(`Translation progress [${videoId}]: ${stage} - ${percent}% - ${message}`);
                
                // Actualizar logs en la tarjeta
                const logsContainer = card.querySelector('.translation-logs');
                if (logsContainer) {
                    const logLine = document.createElement('div');
                    logLine.className = `log-line ${getLogColorClass(stage)}`;
                    logLine.textContent = `[${stage}] ${percent}% - ${message}`;
                    logsContainer.appendChild(logLine);
                    
                    // Mantener solo los √∫ltimos 10 logs para rendimiento
                    const allLogs = logsContainer.querySelectorAll('.log-line');
                    if (allLogs.length > 10) {
                        allLogs[0].remove();
                    }
                }
            }
        }
        
        function getLogColorClass(stage) {
            if (stage === 'error') return 'text-red-400';
            if (stage === 'done') return 'text-green-400';
            if (stage === 'stt') return 'text-blue-400';
            if (stage === 'translation') return 'text-purple-400';
            if (stage === 'tts') return 'text-cyan-400';
            return 'text-gray-300';
        }
        
        function ensureLogsContainer(card) {
            if (!card.querySelector('.translation-logs-container')) {
                const contentDiv = card.querySelector('.p-4');
                if (contentDiv) {
                    const logsHtml = `
                        <div class="translation-logs-container mt-3 p-2 bg-gray-800 rounded border border-gray-700 h-16 overflow-hidden text-xs font-mono relative">
                            <div class="logs-fade-top"></div>
                            <div class="translation-logs text-gray-400">
                                <div class="log-line text-yellow-400">Iniciando traducci√≥n...</div>
                            </div>
                            <div class="logs-fade-bottom"></div>
                        </div>
                    `;
                    contentDiv.insertAdjacentHTML('beforeend', logsHtml);
                }
            }
        }
        
        function ensureTranscriptionLogsContainer(card) {
            if (!card.querySelector('.transcription-logs-container')) {
                const contentDiv = card.querySelector('.p-4');
                if (contentDiv) {
                    const logsHtml = `
                        <div class="transcription-logs-container mt-3 p-2 bg-gray-800 rounded border border-purple-700 h-16 overflow-hidden text-xs font-mono relative">
                            <div class="logs-fade-top"></div>
                            <div class="transcription-logs text-gray-400">
                                <div class="log-line text-purple-400">Iniciando transcripci√≥n...</div>
                            </div>
                            <div class="logs-fade-bottom"></div>
                        </div>
                    `;
                    contentDiv.insertAdjacentHTML('beforeend', logsHtml);
                }
            }
        }
        
        function updateTranscriptionProgress(episodeId, videoId, stage, percent, message) {
            const card = document.querySelector(`.episode-card[data-youtube-id="${videoId}"]`);
            if (card) {
                console.log(`Transcription progress [${videoId}]: ${stage} - ${percent}% - ${message}`);
                
                const logsContainer = card.querySelector('.transcription-logs');
                if (logsContainer) {
                    const logLine = document.createElement('div');
                    logLine.className = `log-line ${getTranscriptionLogColorClass(stage)}`;
                    logLine.textContent = `[${stage}] ${percent}% - ${message}`;
                    logsContainer.appendChild(logLine);
                    
                    const allLogs = logsContainer.querySelectorAll('.log-line');
                    if (allLogs.length > 10) {
                        allLogs[0].remove();
                    }
                }
            }
        }
        
        function getTranscriptionLogColorClass(stage) {
            if (stage === 'error') return 'text-red-400';
            if (stage === 'done') return 'text-green-400';
            if (stage === 'stt') return 'text-purple-400';
            if (stage === 'pdf') return 'text-blue-400';
            return 'text-gray-300';
        }
        
        // Funci√≥n para refrescar una tarjeta de episodio via AJAX
        async function refreshEpisodeCard(episodeId) {
            try {
                const response = await fetch(`/api/episode/${episodeId}/card`);
                if (!response.ok) {
                    console.error('Error fetching episode card:', response.status);
                    return;
                }
                
                const data = await response.json();
                
                // Encontrar la tarjeta actual y reemplazarla
                const currentCard = document.querySelector(`.episode-card[data-episode-id="${episodeId}"]`);
                if (currentCard && data.html) {
                    // Crear un contenedor temporal para parsear el HTML
                    const temp = document.createElement('div');
                    temp.innerHTML = data.html.trim();
                    const newCard = temp.firstElementChild;
                    
                    // Reemplazar la tarjeta
                    currentCard.replaceWith(newCard);
                    
                    // Re-inicializar reproductores de audio en la nueva tarjeta
                    initAudioPlayersInElement(newCard);
                    
                    // Re-attach checkbox listener
                    const checkbox = newCard.querySelector('.episode-checkbox[name="ids"]');
                    if (checkbox) {
                        checkbox.addEventListener('change', updateBulkUI);
                    }
                }
            } catch (err) {
                console.error('Error refreshing episode card:', err);
            }
        }
        
        // Funci√≥n para obtener y mostrar logs de traducci√≥n
        async function fetchAndDisplayLogs(episodeId) {
            try {
                const response = await fetch(`/api/episode/${episodeId}/logs`);
                if (!response.ok) return;
                
                const data = await response.json();
                const card = document.querySelector(`.episode-card[data-episode-id="${episodeId}"]`);
                
                if (card && data.logs && data.logs.length > 0) {
                    const logsContainer = card.querySelector('.translation-logs');
                    if (logsContainer) {
                        // Solo mostrar los √∫ltimos 10 logs
                        const recentLogs = data.logs.slice(-10);
                        logsContainer.innerHTML = recentLogs.map(log => 
                            `<div class="log-line ${getLogColorClass(log.type)}">${escapeHtml(log.message)}</div>`
                        ).join('');
                    }
                }
            } catch (err) {
                console.warn('Error fetching logs:', err);
            }
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Polling fallback for state sync (runs only when there are processing items)
        // This handles cases where SSE events are missed (network issues, server restart, etc.)
        let pollingInterval = null;
        
        function getProcessingEpisodeIds() {
            // Include downloading, translating, and transcribing episodes
            const processingCards = document.querySelectorAll('.episode-card.processing, .episode-card.translating, .episode-card.transcribing');
            const ids = [];
            processingCards.forEach(card => {
                const episodeId = card.dataset.episodeId;
                if (episodeId) ids.push(episodeId);
            });
            return ids;
        }
        
        // Gesti√≥n inteligente del polling - solo activo cuando hay tareas
        function startPollingIfNeeded() {
            const ids = getProcessingEpisodeIds();
            
            if (ids.length > 0 && !pollingInterval) {
                // Iniciar polling solo si hay tareas activas
                pollingInterval = setInterval(pollTaskStatus, 5000);
                console.log('Polling started - active tasks:', ids.length);
            } else if (ids.length === 0 && pollingInterval) {
                // Detener polling si no hay tareas
                clearInterval(pollingInterval);
                pollingInterval = null;
                console.log('Polling stopped - no active tasks');
            }
        }

        async function pollTaskStatus() {
            const ids = getProcessingEpisodeIds();
            if (ids.length === 0) {
                // No hay tareas, detener polling
                startPollingIfNeeded();
                return;
            }

            try {
                const response = await fetch(`/api/task-status?ids=${ids.join(',')}`);
                if (!response.ok) return;
                
                const data = await response.json();
                
                for (const ep of data.episodes) {
                    const card = document.querySelector(`.episode-card[data-episode-id="${ep.id}"]`);
                    if (!card) continue;
                    
                    const wasProcessing = card.classList.contains('processing');
                    const wasTranslating = card.classList.contains('translating');
                    
                    // Si cambi√≥ el estado de descarga
                    if (wasProcessing && (ep.status === 'ready' || ep.status === 'error')) {
                        await refreshEpisodeCard(ep.id);
                        continue;
                    }
                    
                    // Si cambi√≥ el estado de traducci√≥n
                    if (wasTranslating && (ep.translation_status === 'ready' || ep.translation_status === 'error')) {
                        await refreshEpisodeCard(ep.id);
                        continue;
                    }
                    
                    // Si sigue traduciendo, actualizar logs
                    if (ep.translation_status === 'processing') {
                        await fetchAndDisplayLogs(ep.id);
                    }
                    
                    // Si cambi√≥ el estado de transcripci√≥n
                    const wasTranscribing = card.classList.contains('transcribing');
                    if (wasTranscribing && (ep.transcription_status === 'ready' || ep.transcription_status === 'error')) {
                        await refreshEpisodeCard(ep.id);
                        continue;
                    }
                }
                
                // Verificar si debemos seguir con el polling
                startPollingIfNeeded();
            } catch (err) {
                console.warn('Polling failed:', err);
            }
        }

        // Inicializar polling solo si hay tareas activas al cargar
        document.addEventListener('DOMContentLoaded', () => {
            // Verificar despu√©s de un breve delay para dar tiempo a que se renderice
            setTimeout(() => {
                startPollingIfNeeded();
                // Tambi√©n hacer un poll inicial
                pollTaskStatus();
            }, 2000);
        });

        // Walk Mode
        const walkBtn = document.getElementById('walk-mode-btn');
        const walkOverlay = document.getElementById('walk-overlay');
        const unlockArea = document.getElementById('unlock-area');
        let pressTimer;

        walkBtn.addEventListener('click', () => {
            walkOverlay.classList.remove('hidden');
            document.body.style.overflow = 'hidden'; // Prevent scrolling
        });

        const startPress = () => {
            unlockArea.classList.add('border-red-500');
            unlockArea.classList.remove('border-gray-700');
            pressTimer = setTimeout(() => {
                walkOverlay.classList.add('hidden');
                document.body.style.overflow = '';
            }, 1500);
        };

        const endPress = () => {
            clearTimeout(pressTimer);
            unlockArea.classList.remove('border-red-500');
            unlockArea.classList.add('border-gray-700');
        };

        unlockArea.addEventListener('mousedown', startPress);
        unlockArea.addEventListener('touchstart', startPress);
        unlockArea.addEventListener('mouseup', endPress);
        unlockArea.addEventListener('touchend', endPress);
        unlockArea.addEventListener('mouseleave', endPress);

        // === Custom Audio Player ===
        function formatTime(seconds) {
            if (isNaN(seconds) || !isFinite(seconds)) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        // Inicializar reproductores dentro de un elemento espec√≠fico
        function initAudioPlayersInElement(element) {
            element.querySelectorAll('.custom-audio-player').forEach(player => {
                initSingleAudioPlayer(player);
            });
        }
        
        function initSingleAudioPlayer(player) {
            // Evitar re-inicializaci√≥n
            if (player.dataset.initialized) return;
            player.dataset.initialized = 'true';
            
            const audio = player.querySelector('audio');
            const playBtn = player.querySelector('.audio-play-btn');
            const playIcon = player.querySelector('.play-icon');
            const pauseIcon = player.querySelector('.pause-icon');
            const progressBar = player.querySelector('.audio-progress');
            const progressFill = player.querySelector('.audio-progress-fill');
            const timeDisplay = player.querySelector('.audio-time');
            const durationDisplay = player.querySelector('.audio-duration');
            const volumeBtn = player.querySelector('.audio-volume-btn');
            const volumeSlider = player.querySelector('.audio-volume');
            const volumeIcon = player.querySelector('.volume-icon');
            const muteIcon = player.querySelector('.mute-icon');

            if (!audio || !playBtn) return;

            let lastVolume = 0.8;

            // Play/Pause
            playBtn.addEventListener('click', () => {
                // Pause all other players first
                document.querySelectorAll('.custom-audio-player audio').forEach(a => {
                    if (a !== audio && !a.paused) {
                        a.pause();
                        const otherPlayer = a.closest('.custom-audio-player');
                        otherPlayer.classList.remove('playing');
                        otherPlayer.querySelector('.play-icon').classList.remove('hidden');
                        otherPlayer.querySelector('.pause-icon').classList.add('hidden');
                    }
                });

                if (audio.paused) {
                    audio.play();
                    player.classList.add('playing');
                    playIcon.classList.add('hidden');
                    pauseIcon.classList.remove('hidden');
                } else {
                    audio.pause();
                    player.classList.remove('playing');
                    playIcon.classList.remove('hidden');
                    pauseIcon.classList.add('hidden');
                }
            });

            // Update progress
            audio.addEventListener('timeupdate', () => {
                const percent = (audio.currentTime / audio.duration) * 100 || 0;
                progressFill.style.width = percent + '%';
                progressBar.value = percent;
                timeDisplay.textContent = formatTime(audio.currentTime);
            });

            // Duration loaded
            audio.addEventListener('loadedmetadata', () => {
                durationDisplay.textContent = '/ ' + formatTime(audio.duration);
            });

            // Seek
            progressBar.addEventListener('input', (e) => {
                const percent = e.target.value;
                audio.currentTime = (percent / 100) * audio.duration;
                progressFill.style.width = percent + '%';
            });

            // Volume
            volumeSlider.addEventListener('input', (e) => {
                const vol = e.target.value / 100;
                audio.volume = vol;
                lastVolume = vol > 0 ? vol : lastVolume;
                updateVolumeIcon(vol);
            });

            // Mute toggle
            volumeBtn.addEventListener('click', () => {
                if (audio.volume > 0) {
                    lastVolume = audio.volume;
                    audio.volume = 0;
                    volumeSlider.value = 0;
                } else {
                    audio.volume = lastVolume;
                    volumeSlider.value = lastVolume * 100;
                }
                updateVolumeIcon(audio.volume);
            });

            function updateVolumeIcon(vol) {
                if (vol === 0) {
                    volumeIcon.classList.add('hidden');
                    muteIcon.classList.remove('hidden');
                } else {
                    volumeIcon.classList.remove('hidden');
                    muteIcon.classList.add('hidden');
                }
            }

            // Audio ended
            audio.addEventListener('ended', () => {
                player.classList.remove('playing');
                playIcon.classList.remove('hidden');
                pauseIcon.classList.add('hidden');
                progressFill.style.width = '0%';
                progressBar.value = 0;
            });

            // Set initial volume
            audio.volume = 0.8;
        }

        function initAudioPlayers() {
            document.querySelectorAll('.custom-audio-player').forEach(player => {
                initSingleAudioPlayer(player);
            });
        }

        initAudioPlayers();

        // Register Service Worker and Push Notifications
        let swRegistration = null;
        
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js')
                .then(reg => {
                    console.log('Service Worker registrado:', reg.scope);
                    swRegistration = reg;
                    // Check push subscription status
                    checkPushSubscription();
                })
                .catch(err => console.warn('Service Worker error:', err));
        }
        
        // Push Notifications
        const pushBtn = document.getElementById('push-notifications-btn');
        const pushIconOff = document.getElementById('push-icon-off');
        const pushIconOn = document.getElementById('push-icon-on');
        const pushBadge = document.getElementById('push-badge');
        
        async function checkPushSubscription() {
            if (!('PushManager' in window) || !swRegistration) {
                pushBtn.style.display = 'none';
                return;
            }
            
            try {
                const subscription = await swRegistration.pushManager.getSubscription();
                updatePushUI(!!subscription);
                // Verificar si debemos mostrar el banner educativo
                checkAndShowPushBanner(!!subscription);
            } catch (err) {
                console.warn('Error checking push subscription:', err);
            }
        }
        
        // Push Banner Logic
        const pushBanner = document.getElementById('push-banner');
        const pushBannerActivate = document.getElementById('push-banner-activate');
        const pushBannerDismiss = document.getElementById('push-banner-dismiss');
        const PUSH_BANNER_DISMISSED_KEY = 'y2p_push_banner_dismissed';
        
        function checkAndShowPushBanner(isSubscribed) {
            // No mostrar si ya est√° suscrito
            if (isSubscribed) {
                hidePushBanner();
                return;
            }
            
            // No mostrar si el usuario ya lo descart√≥
            if (localStorage.getItem(PUSH_BANNER_DISMISSED_KEY) === 'true') {
                return;
            }
            
            // No mostrar si el permiso ya fue denegado
            if ('Notification' in window && Notification.permission === 'denied') {
                return;
            }
            
            // Mostrar el banner
            pushBanner.classList.remove('hidden');
        }
        
        function hidePushBanner() {
            pushBanner.classList.add('hidden');
        }
        
        function dismissPushBanner() {
            localStorage.setItem(PUSH_BANNER_DISMISSED_KEY, 'true');
            hidePushBanner();
        }
        
        // Event listeners del banner
        pushBannerActivate.addEventListener('click', async () => {
            await togglePushNotifications();
        });
        
        pushBannerDismiss.addEventListener('click', dismissPushBanner);
        
        // Mobile push elements
        const mobilePushBtn = document.getElementById('mobile-push-btn');
        const mobilePushIconOff = document.getElementById('mobile-push-icon-off');
        const mobilePushIconOn = document.getElementById('mobile-push-icon-on');
        const mobilePushLabel = document.getElementById('mobile-push-label');
        
        function updatePushUI(isSubscribed) {
            // Desktop icons
            if (isSubscribed) {
                pushIconOff.classList.add('hidden');
                pushIconOn.classList.remove('hidden');
                pushBadge.classList.remove('hidden');
                pushBtn.title = 'Notificaciones activadas';
            } else {
                pushIconOff.classList.remove('hidden');
                pushIconOn.classList.add('hidden');
                pushBadge.classList.add('hidden');
                pushBtn.title = 'Activar notificaciones';
            }
            // Mobile icons
            if (isSubscribed) {
                mobilePushIconOff.classList.add('hidden');
                mobilePushIconOn.classList.remove('hidden');
                mobilePushLabel.textContent = 'Notificaciones Activas';
            } else {
                mobilePushIconOff.classList.remove('hidden');
                mobilePushIconOn.classList.add('hidden');
                mobilePushLabel.textContent = 'Notificaciones Push';
            }
        }
        
        // Funci√≥n reutilizable para toggle de notificaciones push
        async function togglePushNotifications() {
            if (!('PushManager' in window)) {
                alert('Tu navegador no soporta notificaciones push');
                return false;
            }
            
            if (!swRegistration) {
                alert('Service Worker no disponible');
                return false;
            }
            
            try {
                const subscription = await swRegistration.pushManager.getSubscription();
                
                if (subscription) {
                    // Unsubscribe
                    await subscription.unsubscribe();
                    await fetch('/api/push/unsubscribe', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ endpoint: subscription.endpoint })
                    });
                    updatePushUI(false);
                    return false;
                } else {
                    // Subscribe
                    const permission = await Notification.requestPermission();
                    if (permission !== 'granted') {
                        alert('Permiso de notificaciones denegado');
                        return false;
                    }
                    
                    // Get VAPID public key
                    const keyResponse = await fetch('/api/vapid-public-key');
                    const { publicKey } = await keyResponse.json();
                    
                    // Subscribe to push
                    const newSubscription = await swRegistration.pushManager.subscribe({
                        userVisibleOnly: true,
                        applicationServerKey: urlBase64ToUint8Array(publicKey)
                    });
                    
                    // Send subscription to server
                    await fetch('/api/push/subscribe', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(newSubscription.toJSON())
                    });
                    
                    updatePushUI(true);
                    // Ocultar banner si est√° visible
                    hidePushBanner();
                    return true;
                }
            } catch (err) {
                console.error('Push subscription error:', err);
                alert('Error al configurar notificaciones: ' + err.message);
                return false;
            }
        }
        
        pushBtn.addEventListener('click', togglePushNotifications);
        mobilePushBtn.addEventListener('click', async () => {
            await togglePushNotifications();
            // Update mobile UI after toggle
        });
        
        // Helper function to convert VAPID key
        function urlBase64ToUint8Array(base64String) {
            const padding = '='.repeat((4 - base64String.length % 4) % 4);
            const base64 = (base64String + padding)
                .replace(/-/g, '+')
                .replace(/_/g, '/');
            
            const rawData = window.atob(base64);
            const outputArray = new Uint8Array(rawData.length);
            
            for (let i = 0; i < rawData.length; ++i) {
                outputArray[i] = rawData.charCodeAt(i);
            }
            return outputArray;
        }

        // Theme Toggle - Desktop & Mobile
        const themeToggleBtn = document.getElementById('theme-toggle-btn');
        const themeIconDark = document.getElementById('theme-icon-dark');
        const themeIconLight = document.getElementById('theme-icon-light');
        const mobileThemeToggle = document.getElementById('mobile-theme-toggle');
        const mobileThemeIconDark = document.getElementById('mobile-theme-icon-dark');
        const mobileThemeIconLight = document.getElementById('mobile-theme-icon-light');
        const mobileThemeLabel = document.getElementById('mobile-theme-label');

        function updateThemeIcons() {
            const isDark = document.documentElement.classList.contains('dark');
            // Desktop icons
            if (isDark) {
                themeIconDark.classList.remove('hidden');
                themeIconLight.classList.add('hidden');
            } else {
                themeIconDark.classList.add('hidden');
                themeIconLight.classList.remove('hidden');
            }
            // Mobile icons
            if (isDark) {
                mobileThemeIconDark.classList.remove('hidden');
                mobileThemeIconLight.classList.add('hidden');
                mobileThemeLabel.textContent = 'Modo Oscuro';
            } else {
                mobileThemeIconDark.classList.add('hidden');
                mobileThemeIconLight.classList.remove('hidden');
                mobileThemeLabel.textContent = 'Modo Claro';
            }
        }

        function toggleTheme(e) {
            if (e) e.stopPropagation();
            const isDark = document.documentElement.classList.toggle('dark');
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
            updateThemeIcons();
        }

        // Initialize icons on load
        updateThemeIcons();

        // Theme toggle - both desktop and mobile buttons
        themeToggleBtn.addEventListener('click', toggleTheme);
        mobileThemeToggle.addEventListener('click', toggleTheme);
        
        // === Mobile Walk Mode ===
        const mobileWalkModeBtn = document.getElementById('mobile-walk-mode-btn');
        mobileWalkModeBtn.addEventListener('click', () => {
            closeMobileMenu();
            walkOverlay.classList.remove('hidden');
            document.body.style.overflow = 'hidden';
        });
        
        // === Mobile Sleep Timer ===
        const mobileSleepTimerBtn = document.getElementById('mobile-sleep-timer-btn');
        const mobileTimerBadge = document.getElementById('mobile-timer-badge');
        
        mobileSleepTimerBtn.addEventListener('click', () => {
            closeMobileMenu();
            sleepTimerModal.classList.remove('hidden');
            updateTimerModalDisplay();
        });
        
        // Update mobile timer badge when timer is active
        const originalUpdateTimerDisplay = updateTimerDisplay;
        updateTimerDisplay = function() {
            originalUpdateTimerDisplay();
            if (sleepTimerEndTime) {
                const remaining = Math.max(0, sleepTimerEndTime - Date.now());
                const minutes = Math.floor(remaining / 60000);
                const seconds = Math.floor((remaining % 60000) / 1000);
                mobileTimerBadge.textContent = minutes > 0 ? `${minutes}m` : `${seconds}s`;
                mobileTimerBadge.classList.remove('hidden');
            }
        };
        
        const originalCancelSleepTimer = cancelSleepTimer;
        cancelSleepTimer = function() {
            originalCancelSleepTimer();
            mobileTimerBadge.classList.add('hidden');
            mobileTimerBadge.textContent = '';
        };
    </script>
</body>
</html>
