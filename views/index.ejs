<!DOCTYPE html>
<html lang="es" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Youtube2Podcast</title>
    <link rel="stylesheet" href="/css/styles.css">
    <link rel="stylesheet" href="/css/custom.css">
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#dc2626">
    <link rel="icon" type="image/png" href="/icons/logo.png">
    <link rel="apple-touch-icon" href="/icons/logo.png">
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen flex flex-col">

    <nav class="bg-gray-800 shadow-lg sticky top-0 z-50">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between py-2 items-center">
                <div class="flex items-center gap-4">
                    <img src="/icons/logo.png" alt="Youtube2Podcast" class="w-auto rounded-sm" style="max-width: 80px;">
                    <span class="text-xs bg-gray-700 px-2 py-1 rounded text-gray-300">v1.3</span>
                </div>
                <div class="flex items-center gap-4">
                    <!-- Push Notifications Toggle -->
                    <button id="push-notifications-btn" title="Notificaciones Push" class="text-gray-300 hover:text-white relative">
                        <svg id="push-icon-off" class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9"></path>
                        </svg>
                        <svg id="push-icon-on" class="w-6 h-6 hidden text-green-400" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M12 22c1.1 0 2-.9 2-2h-4c0 1.1.89 2 2 2zm6-6v-5c0-3.07-1.64-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.63 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2z"></path>
                        </svg>
                        <span id="push-badge" class="hidden absolute -top-1 -right-1 w-2 h-2 bg-green-500 rounded-full"></span>
                    </button>
                    
                    <button id="walk-mode-btn" title="Activar Modo Caminata" class="text-gray-300 hover:text-white">
                        <img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQc6rEM9CAB3FlBxasuUJJKgK3N59DTlJ9Xcgi-MlQlEmg6u0Hc2rRXuNRcOd3mJKHU4Wg&usqp=CAU" alt="Modo Caminata" class="w-6 h-6 rounded-full object-cover">
                    </button>
                    
                    <div class="flex items-center gap-2 md:gap-4">
                        <span class="text-gray-400 text-sm hidden md:inline"><%= user %></span>
                        <span class="text-xs bg-gray-700 px-2 py-1 rounded text-gray-300" title="Videos usados">
                            <%= episodeCount %>/<%= quotaLimit %>
                        </span>
                        <% if (typeof isAdmin !== 'undefined' && isAdmin) { %>
                            <a href="/admin" class="admin-link text-sm text-blue-400 hover:text-blue-300">Admin</a>
                        <% } %>
                        <a href="/logout" class="text-gray-400 hover:text-white text-sm">Salir</a>
                    </div>
                </div>
            </div>
        </div>
    </nav>

    <main class="flex-grow container mx-auto px-4 py-8" id="main-content">
        
        <% if (typeof error !== 'undefined' && error) { %>
            <div class="max-w-2xl mx-auto mb-4">
                <div class="bg-red-900/50 border border-red-500 text-red-200 px-4 py-3 rounded-lg text-sm">
                    <%= error %>
                </div>
            </div>
        <% } %>

        <!-- Input Section -->
        <div class="max-w-2xl mx-auto mb-8" id="input-section">
            <form action="/add" method="POST" class="flex gap-4 mb-6" onsubmit="document.getElementById('add-btn').disabled = true; document.getElementById('add-btn').innerText = '...';">
                <input type="url" name="url" placeholder="Pegar URL de YouTube aqu√≠..." required 
                    class="flex-grow px-4 py-3 rounded-lg bg-gray-800 border border-gray-700 focus:border-red-500 focus:ring-1 focus:ring-red-500 outline-none transition duration-200 text-white placeholder-gray-400">
                <button id="add-btn" type="submit" class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg transition duration-200 shadow-lg transform hover:scale-105">
                    Agregar
                </button>
            </form>
            
            <div class="flex justify-between items-center gap-4">
                 <!-- Search Input -->
                <input type="text" id="searchInput" placeholder="Buscar episodios..." 
                    class="flex-grow px-4 py-2 rounded-lg bg-gray-800 border border-gray-700 focus:border-gray-500 outline-none text-gray-300 placeholder-gray-500 text-sm">
                
                <!-- Bulk Actions -->
                 <div class="flex items-center gap-2" id="bulk-actions" style="display: none;">
                    <button onclick="submitBulkDelete()" class="bg-red-900 hover:bg-red-700 text-red-200 text-xs py-2 px-3 rounded border border-red-700 transition">
                        Borrar Seleccionados (<span id="selected-count">0</span>)
                    </button>
                 </div>
            </div>
            <div class="mt-2 flex items-center gap-2">
                <input type="checkbox" id="select-all" class="episode-checkbox" style="margin-right: 0;">
                <label for="select-all" class="text-xs text-gray-400 cursor-pointer select-none">Seleccionar todos</label>
            </div>
        </div>

        <!-- List / Grid -->
        <form id="delete-form" action="/delete" method="POST">
        <% if (episodes.length === 0) { %>
            <div class="text-center text-gray-500 mt-20">
                <p class="text-xl">No hay podcasts a√∫n.</p>
                <p class="text-sm mt-2">Agrega una URL de YouTube para comenzar.</p>
            </div>
        <% } else { %>
            <div id="episodesGrid">
                <% episodes.forEach(episode => { %>
                    <%- include('partials/episode_card', { episode }) %>
                <% }); %>
            </div>
        <% } %>
        </form>

    </main>

    <footer class="bg-gray-800 text-gray-500 py-6 mt-12 text-center text-sm">
        <p>Youtube2Podcast v1.3 | <a href="/logout" class="hover:text-gray-300">Salir</a></p>
    </footer>

    <!-- Voice Selection Modal -->
    <div id="voice-modal" class="fixed inset-0 bg-black bg-opacity-80 z-[9998] hidden flex items-center justify-center p-4">
        <div class="bg-gray-800 rounded-xl shadow-2xl max-w-md w-full max-h-[80vh] overflow-hidden border border-gray-700">
            <div class="p-4 border-b border-gray-700 flex justify-between items-center">
                <h3 class="text-lg font-semibold text-white">Seleccionar Voz</h3>
                <button onclick="closeVoiceModal()" class="text-gray-400 hover:text-white">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="p-4 overflow-y-auto max-h-[60vh]">
                <input type="hidden" id="voice-episode-id" value="">
                
                <!-- Espa√±a -->
                <div class="mb-4">
                    <h4 class="text-sm font-medium text-gray-400 mb-2 flex items-center gap-2">
                        <span>üá™üá∏</span> Espa√±a
                    </h4>
                    <div class="grid grid-cols-2 gap-2">
                        <button type="button" onclick="selectVoice('es-ES-AlvaroNeural')" class="voice-option" data-voice="es-ES-AlvaroNeural">
                            <span class="voice-gender">‚ôÇ</span> √Ålvaro
                        </button>
                        <button type="button" onclick="selectVoice('es-ES-ElviraNeural')" class="voice-option" data-voice="es-ES-ElviraNeural">
                            <span class="voice-gender female">‚ôÄ</span> Elvira
                        </button>
                    </div>
                </div>
                
                <!-- M√©xico -->
                <div class="mb-4">
                    <h4 class="text-sm font-medium text-gray-400 mb-2 flex items-center gap-2">
                        <span>üá≤üáΩ</span> M√©xico
                    </h4>
                    <div class="grid grid-cols-2 gap-2">
                        <button type="button" onclick="selectVoice('es-MX-JorgeNeural')" class="voice-option" data-voice="es-MX-JorgeNeural">
                            <span class="voice-gender">‚ôÇ</span> Jorge
                        </button>
                        <button type="button" onclick="selectVoice('es-MX-DaliaNeural')" class="voice-option" data-voice="es-MX-DaliaNeural">
                            <span class="voice-gender female">‚ôÄ</span> Dalia
                        </button>
                    </div>
                </div>
                
                <!-- Argentina -->
                <div class="mb-4">
                    <h4 class="text-sm font-medium text-gray-400 mb-2 flex items-center gap-2">
                        <span>üá¶üá∑</span> Argentina
                    </h4>
                    <div class="grid grid-cols-2 gap-2">
                        <button type="button" onclick="selectVoice('es-AR-TomasNeural')" class="voice-option" data-voice="es-AR-TomasNeural">
                            <span class="voice-gender">‚ôÇ</span> Tom√°s
                        </button>
                        <button type="button" onclick="selectVoice('es-AR-ElenaNeural')" class="voice-option" data-voice="es-AR-ElenaNeural">
                            <span class="voice-gender female">‚ôÄ</span> Elena
                        </button>
                    </div>
                </div>
                
                <!-- Colombia -->
                <div class="mb-4">
                    <h4 class="text-sm font-medium text-gray-400 mb-2 flex items-center gap-2">
                        <span>üá®üá¥</span> Colombia
                    </h4>
                    <div class="grid grid-cols-2 gap-2">
                        <button type="button" onclick="selectVoice('es-CO-GonzaloNeural')" class="voice-option" data-voice="es-CO-GonzaloNeural">
                            <span class="voice-gender">‚ôÇ</span> Gonzalo
                        </button>
                        <button type="button" onclick="selectVoice('es-CO-SalomeNeural')" class="voice-option" data-voice="es-CO-SalomeNeural">
                            <span class="voice-gender female">‚ôÄ</span> Salom√©
                        </button>
                    </div>
                </div>
            </div>
            <div class="p-4 border-t border-gray-700 flex justify-end gap-3">
                <button onclick="closeVoiceModal()" class="px-4 py-2 text-sm text-gray-400 hover:text-white transition">
                    Cancelar
                </button>
                <button id="start-translation-btn" onclick="confirmVoiceSelection()" class="px-4 py-2 text-sm bg-yellow-600 hover:bg-yellow-500 text-white rounded-lg transition font-medium">
                    Iniciar Traducci√≥n
                </button>
            </div>
        </div>
    </div>

    <!-- Walk Mode Overlay -->
    <div id="walk-overlay" class="fixed inset-0 bg-black bg-opacity-90 z-[9999] hidden flex flex-col items-center justify-center text-center touch-none select-none p-4">
        <div class="text-gray-400 mb-6 sm:mb-8 animate-pulse px-4">
            <svg class="w-12 h-12 sm:w-16 sm:h-16 md:w-20 md:h-20 mx-auto mb-3 sm:mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"></path></svg>
            <h2 class="text-xl sm:text-2xl md:text-3xl font-bold text-white">Modo Caminata Activo</h2>
            <p class="mt-2 text-xs sm:text-sm md:text-base">Pantalla bloqueada para evitar toques accidentales.</p>
        </div>
        <div class="w-40 h-40 sm:w-52 sm:h-52 md:w-64 md:h-64 border-4 border-gray-700 rounded-full flex items-center justify-center active:border-red-500 transition-colors duration-300" id="unlock-area">
            <p class="text-xs sm:text-sm text-gray-500 px-4">Mant√©n presionado para desbloquear</p>
        </div>
    </div>

    <script>
        // Search
        const searchInput = document.getElementById('searchInput');
        if (searchInput) {
            searchInput.addEventListener('keyup', function(e) {
                const term = e.target.value.toLowerCase();
                const cards = document.querySelectorAll('.episode-card');
                cards.forEach(card => {
                    const title = card.querySelector('.episode-title').innerText.toLowerCase();
                    card.style.display = title.includes(term) ? '' : 'none';
                });
            });
        }

        // Selection Logic
        const selectAllCheckbox = document.getElementById('select-all');
        const episodeCheckboxes = document.querySelectorAll('.episode-checkbox[name="ids"]');
        const bulkActionsDiv = document.getElementById('bulk-actions');
        const selectedCountSpan = document.getElementById('selected-count');

        function updateBulkUI() {
            const count = document.querySelectorAll('.episode-checkbox[name="ids"]:checked').length;
            selectedCountSpan.innerText = count;
            bulkActionsDiv.style.display = count > 0 ? 'flex' : 'none';
        }

        selectAllCheckbox.addEventListener('change', (e) => {
            // Re-query in case of dynamic changes, though not expected here
            const currentCheckboxes = document.querySelectorAll('.episode-checkbox[name="ids"]');
            currentCheckboxes.forEach(cb => cb.checked = e.target.checked);
            updateBulkUI();
        });

        // Event delegation for better performance? Or just re-attach
        // Re-querying is safer if we had infinite scroll, but static list for now
        document.querySelectorAll('.episode-checkbox[name="ids"]').forEach(cb => {
            cb.addEventListener('change', updateBulkUI);
        });

        function submitBulkDelete() {
            if (confirm('¬øEst√°s seguro de que deseas eliminar los episodios seleccionados?')) {
                document.getElementById('delete-form').submit();
            }
        }

        function confirmDelete(id) {
            if (confirm('¬øEliminar este episodio?')) {
                const form = document.createElement('form');
                form.method = 'POST';
                form.action = '/delete';
                const input = document.createElement('input');
                input.type = 'hidden';
                input.name = 'ids';
                input.value = id;
                form.appendChild(input);
                document.body.appendChild(form);
                form.submit();
            }
        }

        // SSE for auto-reload when download/translation completes
        let evtSource = null;
        
        function connectSSE() {
            if (evtSource) {
                evtSource.close();
            }
            
            evtSource = new EventSource('/progress');
            
            evtSource.onerror = function(err) {
                console.warn('SSE connection error, will retry...', err);
                evtSource.close();
                // Reconnect after 3 seconds
                setTimeout(connectSSE, 3000);
            };
            
            evtSource.onmessage = handleSSEMessage;
        }
        
        function handleSSEMessage(event) {
            const data = JSON.parse(event.data);
            console.log('SSE Event:', data);

            // Handle translation events
            if (data.type === 'translation') {
                console.log('Translation SSE event:', data);
                if (data.translationStatus === 'ready') {
                    console.log('Translation ready, updating card...');
                    refreshEpisodeCard(data.episodeId);
                } else if (data.translationStatus === 'error') {
                    refreshEpisodeCard(data.episodeId);
                } else if (data.translationStatus === 'processing') {
                    updateTranslationProgress(data.episodeId, data.videoId, data.stage, data.percent, data.message);
                    // Mark card as translating if not already
                    const card = document.querySelector(`.episode-card[data-youtube-id="${data.videoId}"]`);
                    if (card && !card.classList.contains('translating')) {
                        card.classList.add('translating');
                        // A√±adir contenedor de logs si no existe
                        ensureLogsContainer(card);
                    }
                }
                return;
            }

            // Handle download events
            if (data.status === 'done') {
                // Buscar el episodeId por videoId
                const card = document.querySelector(`.episode-card[data-youtube-id="${data.videoId}"]`);
                if (card) {
                    refreshEpisodeCard(card.dataset.episodeId);
                }
            } else if (data.status === 'error') {
                updateCardToError(data.videoId);
            }
        }
        
        // Initialize SSE connection
        connectSSE();

        // Helper function to update a card to error state
        function updateCardToError(videoId) {
            const card = document.querySelector(`.episode-card[data-youtube-id="${videoId}"]`);
            if (card) {
                card.classList.remove('processing');
                const statusSpan = card.querySelector('.card-date span');
                if (statusSpan) {
                    statusSpan.className = 'text-red-500';
                    statusSpan.innerText = 'Error';
                }
                const thumbContainer = card.querySelector('.aspect-video > div');
                if (thumbContainer) {
                    thumbContainer.innerHTML = `
                        <svg class="w-6 h-6 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                        </svg>
                    `;
                }
            }
        }

        // Voice Selection Modal
        let selectedVoice = 'es-ES-AlvaroNeural';
        const voiceModal = document.getElementById('voice-modal');
        const voiceEpisodeIdInput = document.getElementById('voice-episode-id');
        
        function openVoiceModal(episodeId) {
            voiceEpisodeIdInput.value = episodeId;
            selectedVoice = 'es-ES-AlvaroNeural'; // Reset to default
            // Reset visual selection
            document.querySelectorAll('.voice-option').forEach(btn => btn.classList.remove('selected'));
            document.querySelector('.voice-option[data-voice="es-ES-AlvaroNeural"]').classList.add('selected');
            voiceModal.classList.remove('hidden');
        }
        
        function closeVoiceModal() {
            voiceModal.classList.add('hidden');
        }
        
        function selectVoice(voice) {
            selectedVoice = voice;
            document.querySelectorAll('.voice-option').forEach(btn => btn.classList.remove('selected'));
            document.querySelector(`.voice-option[data-voice="${voice}"]`).classList.add('selected');
        }
        
        function confirmVoiceSelection() {
            const episodeId = voiceEpisodeIdInput.value;
            closeVoiceModal();
            startTranslation(episodeId, selectedVoice);
        }
        
        // Close modal on backdrop click
        voiceModal.addEventListener('click', (e) => {
            if (e.target === voiceModal) closeVoiceModal();
        });
        
        // Close modal on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && !voiceModal.classList.contains('hidden')) {
                closeVoiceModal();
            }
        });

        // Translation Functions
        async function startTranslation(episodeId, voice = 'es-ES-AlvaroNeural') {
            try {
                const response = await fetch(`/translate/${episodeId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ voice })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    // Actualizar tarjeta sin recargar p√°gina
                    await refreshEpisodeCard(episodeId);
                } else {
                    alert('Error: ' + (data.error || 'No se pudo iniciar la traducci√≥n'));
                }
            } catch (err) {
                console.error('Translation error:', err);
                alert('Error de conexi√≥n al iniciar la traducci√≥n');
            }
        }

        function updateTranslationProgress(episodeId, videoId, stage, percent, message) {
            const card = document.querySelector(`.episode-card[data-youtube-id="${videoId}"]`);
            if (card) {
                console.log(`Translation progress [${videoId}]: ${stage} - ${percent}% - ${message}`);
                
                // Actualizar logs en la tarjeta
                const logsContainer = card.querySelector('.translation-logs');
                if (logsContainer) {
                    const logLine = document.createElement('div');
                    logLine.className = `log-line ${getLogColorClass(stage)}`;
                    logLine.textContent = `[${stage}] ${percent}% - ${message}`;
                    logsContainer.appendChild(logLine);
                    
                    // Mantener solo los √∫ltimos 10 logs para rendimiento
                    const allLogs = logsContainer.querySelectorAll('.log-line');
                    if (allLogs.length > 10) {
                        allLogs[0].remove();
                    }
                }
            }
        }
        
        function getLogColorClass(stage) {
            if (stage === 'error') return 'text-red-400';
            if (stage === 'done') return 'text-green-400';
            if (stage === 'stt') return 'text-blue-400';
            if (stage === 'translation') return 'text-purple-400';
            if (stage === 'tts') return 'text-cyan-400';
            return 'text-gray-300';
        }
        
        function ensureLogsContainer(card) {
            if (!card.querySelector('.translation-logs-container')) {
                const contentDiv = card.querySelector('.p-4');
                if (contentDiv) {
                    const logsHtml = `
                        <div class="translation-logs-container mt-3 p-2 bg-gray-800 rounded border border-gray-700 h-16 overflow-hidden text-xs font-mono relative">
                            <div class="logs-fade-top"></div>
                            <div class="translation-logs text-gray-400">
                                <div class="log-line text-yellow-400">Iniciando traducci√≥n...</div>
                            </div>
                            <div class="logs-fade-bottom"></div>
                        </div>
                    `;
                    contentDiv.insertAdjacentHTML('beforeend', logsHtml);
                }
            }
        }
        
        // Funci√≥n para refrescar una tarjeta de episodio via AJAX
        async function refreshEpisodeCard(episodeId) {
            try {
                const response = await fetch(`/api/episode/${episodeId}/card`);
                if (!response.ok) {
                    console.error('Error fetching episode card:', response.status);
                    return;
                }
                
                const data = await response.json();
                
                // Encontrar la tarjeta actual y reemplazarla
                const currentCard = document.querySelector(`.episode-card[data-episode-id="${episodeId}"]`);
                if (currentCard && data.html) {
                    // Crear un contenedor temporal para parsear el HTML
                    const temp = document.createElement('div');
                    temp.innerHTML = data.html.trim();
                    const newCard = temp.firstElementChild;
                    
                    // Reemplazar la tarjeta
                    currentCard.replaceWith(newCard);
                    
                    // Re-inicializar reproductores de audio en la nueva tarjeta
                    initAudioPlayersInElement(newCard);
                    
                    // Re-attach checkbox listener
                    const checkbox = newCard.querySelector('.episode-checkbox[name="ids"]');
                    if (checkbox) {
                        checkbox.addEventListener('change', updateBulkUI);
                    }
                }
            } catch (err) {
                console.error('Error refreshing episode card:', err);
            }
        }
        
        // Funci√≥n para obtener y mostrar logs de traducci√≥n
        async function fetchAndDisplayLogs(episodeId) {
            try {
                const response = await fetch(`/api/episode/${episodeId}/logs`);
                if (!response.ok) return;
                
                const data = await response.json();
                const card = document.querySelector(`.episode-card[data-episode-id="${episodeId}"]`);
                
                if (card && data.logs && data.logs.length > 0) {
                    const logsContainer = card.querySelector('.translation-logs');
                    if (logsContainer) {
                        // Solo mostrar los √∫ltimos 10 logs
                        const recentLogs = data.logs.slice(-10);
                        logsContainer.innerHTML = recentLogs.map(log => 
                            `<div class="log-line ${getLogColorClass(log.type)}">${escapeHtml(log.message)}</div>`
                        ).join('');
                    }
                }
            } catch (err) {
                console.warn('Error fetching logs:', err);
            }
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Polling fallback for state sync (runs every 10s if there are processing items)
        // This handles cases where SSE events are missed (network issues, server restart, etc.)
        function getProcessingEpisodeIds() {
            // Include both downloading and translating episodes
            const processingCards = document.querySelectorAll('.episode-card.processing, .episode-card.translating');
            const ids = [];
            processingCards.forEach(card => {
                const episodeId = card.dataset.episodeId;
                if (episodeId) ids.push(episodeId);
            });
            return ids;
        }

        async function pollTaskStatus() {
            const ids = getProcessingEpisodeIds();
            if (ids.length === 0) return;

            try {
                const response = await fetch(`/api/task-status?ids=${ids.join(',')}`);
                if (!response.ok) return;
                
                const data = await response.json();
                
                for (const ep of data.episodes) {
                    const card = document.querySelector(`.episode-card[data-episode-id="${ep.id}"]`);
                    if (!card) continue;
                    
                    const wasProcessing = card.classList.contains('processing');
                    const wasTranslating = card.classList.contains('translating');
                    
                    // Si cambi√≥ el estado de descarga
                    if (wasProcessing && (ep.status === 'ready' || ep.status === 'error')) {
                        await refreshEpisodeCard(ep.id);
                        continue;
                    }
                    
                    // Si cambi√≥ el estado de traducci√≥n
                    if (wasTranslating && (ep.translation_status === 'ready' || ep.translation_status === 'error')) {
                        await refreshEpisodeCard(ep.id);
                        continue;
                    }
                    
                    // Si sigue traduciendo, actualizar logs
                    if (ep.translation_status === 'processing') {
                        await fetchAndDisplayLogs(ep.id);
                    }
                }
            } catch (err) {
                console.warn('Polling failed:', err);
            }
        }

        // Start polling interval (every 5 seconds for better UX)
        setInterval(pollTaskStatus, 5000);
        // Also poll once on page load after a short delay (catch immediate state changes)
        setTimeout(pollTaskStatus, 2000);

        // Walk Mode
        const walkBtn = document.getElementById('walk-mode-btn');
        const walkOverlay = document.getElementById('walk-overlay');
        const unlockArea = document.getElementById('unlock-area');
        let pressTimer;

        walkBtn.addEventListener('click', () => {
            walkOverlay.classList.remove('hidden');
            document.body.style.overflow = 'hidden'; // Prevent scrolling
        });

        const startPress = () => {
            unlockArea.classList.add('border-red-500');
            unlockArea.classList.remove('border-gray-700');
            pressTimer = setTimeout(() => {
                walkOverlay.classList.add('hidden');
                document.body.style.overflow = '';
            }, 1500);
        };

        const endPress = () => {
            clearTimeout(pressTimer);
            unlockArea.classList.remove('border-red-500');
            unlockArea.classList.add('border-gray-700');
        };

        unlockArea.addEventListener('mousedown', startPress);
        unlockArea.addEventListener('touchstart', startPress);
        unlockArea.addEventListener('mouseup', endPress);
        unlockArea.addEventListener('touchend', endPress);
        unlockArea.addEventListener('mouseleave', endPress);

        // === Custom Audio Player ===
        function formatTime(seconds) {
            if (isNaN(seconds) || !isFinite(seconds)) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        // Inicializar reproductores dentro de un elemento espec√≠fico
        function initAudioPlayersInElement(element) {
            element.querySelectorAll('.custom-audio-player').forEach(player => {
                initSingleAudioPlayer(player);
            });
        }
        
        function initSingleAudioPlayer(player) {
            // Evitar re-inicializaci√≥n
            if (player.dataset.initialized) return;
            player.dataset.initialized = 'true';
            
            const audio = player.querySelector('audio');
            const playBtn = player.querySelector('.audio-play-btn');
            const playIcon = player.querySelector('.play-icon');
            const pauseIcon = player.querySelector('.pause-icon');
            const progressBar = player.querySelector('.audio-progress');
            const progressFill = player.querySelector('.audio-progress-fill');
            const timeDisplay = player.querySelector('.audio-time');
            const durationDisplay = player.querySelector('.audio-duration');
            const volumeBtn = player.querySelector('.audio-volume-btn');
            const volumeSlider = player.querySelector('.audio-volume');
            const volumeIcon = player.querySelector('.volume-icon');
            const muteIcon = player.querySelector('.mute-icon');

            if (!audio || !playBtn) return;

            let lastVolume = 0.8;

            // Play/Pause
            playBtn.addEventListener('click', () => {
                // Pause all other players first
                document.querySelectorAll('.custom-audio-player audio').forEach(a => {
                    if (a !== audio && !a.paused) {
                        a.pause();
                        const otherPlayer = a.closest('.custom-audio-player');
                        otherPlayer.classList.remove('playing');
                        otherPlayer.querySelector('.play-icon').classList.remove('hidden');
                        otherPlayer.querySelector('.pause-icon').classList.add('hidden');
                    }
                });

                if (audio.paused) {
                    audio.play();
                    player.classList.add('playing');
                    playIcon.classList.add('hidden');
                    pauseIcon.classList.remove('hidden');
                } else {
                    audio.pause();
                    player.classList.remove('playing');
                    playIcon.classList.remove('hidden');
                    pauseIcon.classList.add('hidden');
                }
            });

            // Update progress
            audio.addEventListener('timeupdate', () => {
                const percent = (audio.currentTime / audio.duration) * 100 || 0;
                progressFill.style.width = percent + '%';
                progressBar.value = percent;
                timeDisplay.textContent = formatTime(audio.currentTime);
            });

            // Duration loaded
            audio.addEventListener('loadedmetadata', () => {
                durationDisplay.textContent = '/ ' + formatTime(audio.duration);
            });

            // Seek
            progressBar.addEventListener('input', (e) => {
                const percent = e.target.value;
                audio.currentTime = (percent / 100) * audio.duration;
                progressFill.style.width = percent + '%';
            });

            // Volume
            volumeSlider.addEventListener('input', (e) => {
                const vol = e.target.value / 100;
                audio.volume = vol;
                lastVolume = vol > 0 ? vol : lastVolume;
                updateVolumeIcon(vol);
            });

            // Mute toggle
            volumeBtn.addEventListener('click', () => {
                if (audio.volume > 0) {
                    lastVolume = audio.volume;
                    audio.volume = 0;
                    volumeSlider.value = 0;
                } else {
                    audio.volume = lastVolume;
                    volumeSlider.value = lastVolume * 100;
                }
                updateVolumeIcon(audio.volume);
            });

            function updateVolumeIcon(vol) {
                if (vol === 0) {
                    volumeIcon.classList.add('hidden');
                    muteIcon.classList.remove('hidden');
                } else {
                    volumeIcon.classList.remove('hidden');
                    muteIcon.classList.add('hidden');
                }
            }

            // Audio ended
            audio.addEventListener('ended', () => {
                player.classList.remove('playing');
                playIcon.classList.remove('hidden');
                pauseIcon.classList.add('hidden');
                progressFill.style.width = '0%';
                progressBar.value = 0;
            });

            // Set initial volume
            audio.volume = 0.8;
        }

        function initAudioPlayers() {
            document.querySelectorAll('.custom-audio-player').forEach(player => {
                initSingleAudioPlayer(player);
            });
        }

        initAudioPlayers();

        // Register Service Worker and Push Notifications
        let swRegistration = null;
        
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js')
                .then(reg => {
                    console.log('Service Worker registrado:', reg.scope);
                    swRegistration = reg;
                    // Check push subscription status
                    checkPushSubscription();
                })
                .catch(err => console.warn('Service Worker error:', err));
        }
        
        // Push Notifications
        const pushBtn = document.getElementById('push-notifications-btn');
        const pushIconOff = document.getElementById('push-icon-off');
        const pushIconOn = document.getElementById('push-icon-on');
        const pushBadge = document.getElementById('push-badge');
        
        async function checkPushSubscription() {
            if (!('PushManager' in window) || !swRegistration) {
                pushBtn.style.display = 'none';
                return;
            }
            
            try {
                const subscription = await swRegistration.pushManager.getSubscription();
                updatePushUI(!!subscription);
            } catch (err) {
                console.warn('Error checking push subscription:', err);
            }
        }
        
        function updatePushUI(isSubscribed) {
            if (isSubscribed) {
                pushIconOff.classList.add('hidden');
                pushIconOn.classList.remove('hidden');
                pushBadge.classList.remove('hidden');
                pushBtn.title = 'Notificaciones activadas';
            } else {
                pushIconOff.classList.remove('hidden');
                pushIconOn.classList.add('hidden');
                pushBadge.classList.add('hidden');
                pushBtn.title = 'Activar notificaciones';
            }
        }
        
        pushBtn.addEventListener('click', async () => {
            if (!('PushManager' in window)) {
                alert('Tu navegador no soporta notificaciones push');
                return;
            }
            
            if (!swRegistration) {
                alert('Service Worker no disponible');
                return;
            }
            
            try {
                const subscription = await swRegistration.pushManager.getSubscription();
                
                if (subscription) {
                    // Unsubscribe
                    await subscription.unsubscribe();
                    await fetch('/api/push/unsubscribe', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ endpoint: subscription.endpoint })
                    });
                    updatePushUI(false);
                } else {
                    // Subscribe
                    const permission = await Notification.requestPermission();
                    if (permission !== 'granted') {
                        alert('Permiso de notificaciones denegado');
                        return;
                    }
                    
                    // Get VAPID public key
                    const keyResponse = await fetch('/api/vapid-public-key');
                    const { publicKey } = await keyResponse.json();
                    
                    // Subscribe to push
                    const newSubscription = await swRegistration.pushManager.subscribe({
                        userVisibleOnly: true,
                        applicationServerKey: urlBase64ToUint8Array(publicKey)
                    });
                    
                    // Send subscription to server
                    await fetch('/api/push/subscribe', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(newSubscription.toJSON())
                    });
                    
                    updatePushUI(true);
                }
            } catch (err) {
                console.error('Push subscription error:', err);
                alert('Error al configurar notificaciones: ' + err.message);
            }
        });
        
        // Helper function to convert VAPID key
        function urlBase64ToUint8Array(base64String) {
            const padding = '='.repeat((4 - base64String.length % 4) % 4);
            const base64 = (base64String + padding)
                .replace(/-/g, '+')
                .replace(/_/g, '/');
            
            const rawData = window.atob(base64);
            const outputArray = new Uint8Array(rawData.length);
            
            for (let i = 0; i < rawData.length; ++i) {
                outputArray[i] = rawData.charCodeAt(i);
            }
            return outputArray;
        }
    </script>
</body>
</html>
